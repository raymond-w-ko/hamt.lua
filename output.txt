key: 85035710 -> hash: 29117953
key: 27815778 -> hash: 164384257
key: 14756006 -> hash: 29117953
--------------------
hash NOT matches
Collision:lookup() hash:164384257 key:27815778
__unnamed__ = {
   ["children"] = {
      [1] = {
         ["hash"] = 29117953;
         ["key"] = "14756006";
      };
      [2] = {
         ["hash"] = 29117953;
         ["key"] = "85035710";
      };
   };
   ["hash"] = 29117953;
};

--------------------
hash NOT matches
Collision:lookup() hash:2136828029 key:6188899
__unnamed__ = {
   ["children"] = {
      [1] = {
         ["hash"] = -1774360451;
         ["key"] = "20797268";
      };
      [2] = {
         ["hash"] = -1774360451;
         ["key"] = "91076972";
      };
   };
   ["hash"] = -1774360451;
};

--------------------
hash NOT matches
Collision:lookup() hash:-17202439 key:51524587
__unnamed__ = {
   ["children"] = {
      [1] = {
         ["hash"] = 1716093689;
         ["key"] = "11927216";
      };
      [2] = {
         ["hash"] = 1716093689;
         ["key"] = "82206920";
      };
   };
   ["hash"] = 1716093689;
};

--------------------
hash NOT matches
Collision:lookup() hash:-644008964 key:55962001
__unnamed__ = {
   ["children"] = {
      [1] = {
         ["hash"] = 776811516;
         ["key"] = "10785078";
      };
      [2] = {
         ["hash"] = 776811516;
         ["key"] = "81064782";
      };
   };
   ["hash"] = 776811516;
};

--------------------
hash NOT matches
Collision:lookup() hash:-1790772637 key:62186468
__unnamed__ = {
   ["children"] = {
      [1] = {
         ["hash"] = 1664285283;
         ["key"] = "82063743";
      };
      [2] = {
         ["hash"] = 1664285283;
         ["key"] = "11784039";
      };
   };
   ["hash"] = 1664285283;
};


====== .\hamt.lua ======
@@ 29 @@
      | local function slow_len(t)
      |   local count = 0
      |   for k, v in pairs(t) do
   8% |     count = count + 1
      |   end
      |   return count
      | end
@@ 80 @@
      | function M.arrayUpdate(index, new_value, array, max_bounds)
      |   -- pre allocate an array part with 32 slots. this seems to speed things up
      |   -- since the following copy phase doesn't need to trigger a re-hash
  15% |   local copy = {
      |     nil, nil, nil, nil, nil, nil, nil, nil,
      |     nil, nil, nil, nil, nil, nil, nil, nil,
      |     nil, nil, nil, nil, nil, nil, nil, nil,
@@ 91 @@
      |   -- always work properly on an array with holes like in Javascript
      |   --for i = 1, #array do
      |   --for i = 1, max_bounds do
   3% |   for i = 1, max_bounds do
   3% |     copy[i] = array[i]
      |   end
      |   copy[index + 1] = new_value
      | 
@@ 141 @@
      |   index = index + 1
      | 
      |   local copy = {}
   3% |   local i = 1
      |   local j = 1
      |   while true do
      |     local item = array[i]
@@ 258 @@
      | local ArrayNodeMetatable = {__index = ArrayNode}
      | 
      | function ArrayNode.new(count, children)
  13% |   return setmetatable({count = count, children = children}, ArrayNodeMetatable)
      | end
      | 
      | --------------------------------------------------------------------------------
@@ 469 @@
      | function ArrayNode:lookup(shift, hash, key)
      |   -- hashFragment(shift, hash)
      |   local frag = band(rshift(hash, shift), MASK)
   3% |   local child = self.children[frag + 1] -- NOTICE: 0 index to 1 index
      |   return lookup(child, shift + SIZE, hash, key)
      | end
      | 
@@ 477 @@
      |   if node == nil then
      |     return nothing
      |   else
   4% |     return node:lookup(shift, hash, key)
      |   end
      | end
      | 

====== correctness_tests.lua ======
@@ 11 @@
      | for i = 1, bounds do
      |   local key
      |   for try = 1, 64 do
   9% |     key = tostring(math.random(1, 100000000))
      |     if existing_keys[key] == nil then
      |       existing_keys[key] = true
      |       break
