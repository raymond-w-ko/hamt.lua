key: 85035710 -> hash: 29117953
key: 27815778 -> hash: 164384257
key: 14756006 -> hash: 29117953
--------------------
hash NOT matches
Collision:lookup() hash:164384257 key:27815778
__unnamed__ = {
   ["children"] = {
      [1] = {
         ["hash"] = 29117953;
         ["key"] = "14756006";
      };
      [2] = {
         ["hash"] = 29117953;
         ["key"] = "85035710";
      };
   };
   ["hash"] = 29117953;
};

arg hash: 164384257
key: 27815778
internal hash: 29117953

====== .\hamt.lua ======
@@ 29 @@
      | local function slow_len(t)
      |   local count = 0
      |   for k, v in pairs(t) do
   6% |     count = count + 1
      |   end
      |   return count
      | end
@@ 80 @@
      | function M.arrayUpdate(index, new_value, array, max_bounds)
      |   -- pre allocate an array part with 32 slots. this seems to speed things up
      |   -- since the following copy phase doesn't need to trigger a re-hash
  17% |   local copy = {
      |     nil, nil, nil, nil, nil, nil, nil, nil,
      |     nil, nil, nil, nil, nil, nil, nil, nil,
      |     nil, nil, nil, nil, nil, nil, nil, nil,
@@ 91 @@
      |   -- always work properly on an array with holes like in Javascript
      |   --for i = 1, #array do
      |   --for i = 1, max_bounds do
   3% |   for i = 1, max_bounds do
      |     copy[i] = array[i]
      |   end
      |   copy[index + 1] = new_value
@@ 141 @@
      |   index = index + 1
      | 
      |   local copy = {}
   4% |   local i = 1
      |   local j = 1
      |   while true do
      |     local item = array[i]
@@ 243 @@
      | local IndexedNodeMetatable = {__index = IndexedNode}
      | 
      | function IndexedNode.new(mask, children)
   3% |   return setmetatable({mask = mask, children = children}, IndexedNodeMetatable)
      | end
      | 
      | --------------------------------------------------------------------------------
@@ 258 @@
      | local ArrayNodeMetatable = {__index = ArrayNode}
      | 
      | function ArrayNode.new(count, children)
  18% |   return setmetatable({count = count, children = children}, ArrayNodeMetatable)
      | end
      | 
      | --------------------------------------------------------------------------------
@@ 477 @@
      |   if node == nil then
      |     return nothing
      |   else
   3% |     return node:lookup(shift, hash, key)
      |   end
      | end
      | 
@@ 575 @@
      |   local frag = band(rshift(hash, shift), MASK)
      |   local child = children[frag + 1] -- NOTICE: 0 index to 1 index
      |   local newChild = alter(child, shift + SIZE, fn, hash, key)
   3% |   if child == nil and newChild ~= nil then
      |     return ArrayNode.new(count + 1, arrayUpdate(frag, newChild, children, BUCKET_SIZE))
      |   elseif child ~= nil and newChild == nil then
      |     if (count - 1) <= MIN_ARRAY_NODE then

====== correctness_tests.lua ======
@@ 11 @@
      | for i = 1, bounds do
      |   local key
      |   for try = 1, 64 do
  13% |     key = tostring(math.random(1, 100000000))
      |     if existing_keys[key] == nil then
      |       existing_keys[key] = true
   3% |       break
      |     else
      |       key = nil
      |     end
